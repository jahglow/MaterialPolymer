<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="..\..\bower_components/polymer/polymer.html">
<link rel="import" href="..\..\bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="..\..\bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="..\reportal-table-behavior/reportal-table-behavior.html">


<dom-module id="reportal-aggregated-table">
  <template>
    <style>
      :host {
        display: block;
        width:100%;
        height:auto
      }
      #source{display:none}
      #grid>vaadin-grid .numeric{text-align: right}
    </style>
    <div id="source"><content></content></div>
    <div id="grid"></div>
  </template>
  <script>
    (function(){
      'use strict';

      Polymer({
        is: 'reportal-aggregated-table',
        listeners:{
          //'tap':'_sortChange',
          //'vgrid.sort-order-changed':'_sorttry'
          //'action-data-change':'voiceControl'
        },
        behaviors: [
          Polymer.IronResizableBehavior,
          Polymer.ReportalTableBehavior
        ],

        /*many properties and methods are inherited from ReportalTableBehavior */

        properties: {
          selectionMode:{
            type:String,
            value: 'disabled'
          },
          _sortedColumn:{
            type:Number,
            value:null
          },
          indexed:{
            type:Boolean,
            value:false
          },
          indexedHeader:{
            type:String,
            value:'#'
          }
        },
        ready:function(){
          if(this.colattrLegacy && this.colattrLegacy.length>0){
            this._processLegacyAttributes(this.colattrLegacy);
          }
          var grid = document.createElement('vaadin-grid');
          var table = this.$.source.querySelector('table');
          if(table){
            this.grid = grid;
            this._defineData(table);
            this._defineHeader(grid,table);
            if(this.visibleRows){grid.rows=this.visibleRows;}
            if(this.selectionMode){grid.selection.mode=this.selectionMode;}
            if(this.frozenColumns){
              if(this.indexed){this.frozenColumns+=1;}
              grid.frozenColumns=this.frozenColumns;
            }
            Polymer.dom(grid).setAttribute('id','vgrid');
            Polymer.dom(this.$.grid).appendChild(grid);
            var that=this;
            this.grid.addEventListener('sort-order-changed',function(e){return that._sortChange(e)})
          }
        },
        attached:function(){
          this.async(this.notifyResize,100);
        },
        _defineData:function(table){
          this.data=[];
          var rows;
          for(var ch=0;ch<table.children.length;ch++){
            // we want to get the topmost table and not its cells content tables if any
            if(table.children[ch].localName==='tbody'){rows=table.children[ch].children; break;}
          }
          if(rows){
            for(var i=0;i<rows.length;i++){
              var curRow=[];
              if(this.indexed){curRow.push(i+1);}//append index
              for(var ri=0;ri<rows[i].children.length;ri++){
                //checks if this cell has HTML tags inside, probably we need to keep them
                curRow.push(rows[i].children[ri].children.length>0?rows[i].children[ri].innerHTML:rows[i].children[ri].textContent.trim());
                var csp=rows[i].children[ri].getAttribute('colspan');
                if(csp){
                  for(var ci=1;ci<csp;ci++){
                    curRow.push('');
                  }
                }
              }
              this.data.push(curRow);
            }
          }
          this.grid.items = this.data;
          //console.log(this.grid.items)
          // append conditional formatting from corresponding table cells
          this.grid.cellClassGenerator = function(cell){
            return rows[cell.row.index].children[cell.index].className;
          };
        },
        /*_defineAttr:function(propN,propV){
         if(propV){
         if(typeof propV === 'string'){
         return ' '+propN+'="'+propV+'"';
         } else if (typeof propV === 'boolean') {
         return ' '+propN;
         }
         }
         },*/
        _defineHeader:function(host,source){
          Object.size = function(obj) {
            var size = 0, key;
            for (key in obj) {
              if (obj.hasOwnProperty(key)) size++;
            }
            return size;
          };

          //first define column quantity of the table
          var columns = this._getImmediateChildrenByName(source,'tbody')[0].lastElementChild.children;
          var columnsCount = columns.length;

          if(this.indexed){
            host.addColumn({headerContent:this.indexedHeader, maxWidth:'100px', sortable:true}); //append index
            columnsCount++;
          }
          //console.log('total columns: '+columnsCount);
          var thead = this._getImmediateChildrenByName(source,'thead')[0];
          var rowcount = thead.children.length;
          //console.log('rowcount '+rowcount);
          var abstraction = {};
          for(var a=0;a<rowcount;a++){
            var realRow = thead.children[a]; //real row
            //console.log(realRow);
            //console.log('row '+a +'exists? '+abstraction.hasOwnProperty(a.toString()));
            var aRow = abstraction[a] = abstraction[a] || {}; //abstraction row (might exist)
            //console.log('row '+a +'exists? '+abstraction.hasOwnProperty(a.toString()));

            var aRowLength = 0;
            for(var rowTD = 0; rowTD<realRow.children.length;rowTD++){
              var curTD = realRow.children[rowTD]; //current cell
              var realIndex;
              //console.log(curTD);
              var colspan = curTD.colSpan;
              var rowspan = curTD.rowSpan;
              var label = curTD.textContent;
              //console.log('colSpan '+ colspan)
              //console.log('rowspan '+rowspan)
              //console.log('label '+label)

              if(colspan||rowspan||label){
                var finalTDcellIndex=rowTD;
                /* if entry exists (there was a rowspan in previous row and it transferred label to next possible row), we need to find a new home for curTD
                 * all cells are filled sequentially, so we need to find a break in indexing sequence*/
                //console.log(aRow.hasOwnProperty(rowTD))// create cell for this abstract row
                if(aRow.hasOwnProperty(rowTD)) { //this entry exists (it can exist if was filled by previous row where a cell had a rowspan)
                  //console.log(rowTD+' cell exists, will search for new place');
                  var realTDindex = 0;
                  var cellIsFound = false;
                  for (key in aRow) {
                    if (parseInt(key) === realTDindex) {
                      //console.log(key+' cell is also used');
                      realTDindex++
                    } else {
                      cellIsFound = true;
                      //console.log(realTDindex+' cell is just perfect');
                      finalTDcellIndex = realTDindex;
                      break;
                    }
                  }
                  if(!cellIsFound){
                    //console.log('we\'ve ran out of options with'+ realTDindex+' cell, let\'s make it a '+ realTDindex+1 +' ?');
                    finalTDcellIndex = realTDindex++;
                  }
                }
                var key = a; //is this current row or it has rowspan and we append label to the bottommost row?
                //console.log('has rowspan, current row is' + a+' cell is '+finalTDcellIndex);
                if(!rowspan){rowspan=1}
                for(var ri=0;ri<rowspan;ri++){
                  if(rowspan){key=a+ri;}
                  //console.log('row is '+key);
                  //console.log('from rowspan row '+key+' exists? '+abstraction.hasOwnProperty(key))
                  if(!abstraction.hasOwnProperty(key)){abstraction[key]={}}// is there such a row in abstraction?
                  //console.log('from rowspan cell '+finalTDcellIndex+' exists? '+abstraction[key].hasOwnProperty(finalTDcellIndex))
                  if(!abstraction[key].hasOwnProperty(finalTDcellIndex)){
                    abstraction[key][finalTDcellIndex]={};
                    if(ri===rowspan-1){ // if it's the last row
                      abstraction[key][finalTDcellIndex].label = label.trim().length>0?label.trim():''; // use label if more than empty else empty string
                    } else {abstraction[key][finalTDcellIndex].label = ''}
                  } else {

                  }
                  if(colspan>1){abstraction[key][finalTDcellIndex].colspan = colspan;}
                }
                if(abstraction[key]!==abstraction[a]){aRow[finalTDcellIndex].label = ''} // if there was rowspan, this cell is empty and needs empty label
              } else {aRow[rowTD].label=''}
              //console.log(JSON.stringify(abstraction));
              aRowLength++;
            }
          }

          if(columns && columns.length>0){
            var colattr = this.colattr;
            for(var i=0;i<columns.length;i++){
              var colProp = {};
              if(colattr[i]){
                for(var ci=0;ci<colattr[i].length;ci++){ // populate column properties
                  if(colattr[i][ci].length>0){
                    this._a2o(colProp,colattr[i][ci][0],colattr[i][ci][1]);
                  }
                }
              }
              host.addColumn(colProp);
            }
          }

          for(var idx in abstraction){
            if(idx>0){
              //console.log('will add a row');
              host.header.addRow();
            }
            //console.log(typeof parseInt(idx));
            if(parseInt(idx)===(parseInt(rowcount)-1)){
              host.header.defaultRow = parseInt(rowcount)-1;
              //console.log('defaultRow '+host.header.defaultRow);
            }
            this._fillHeaderRow(idx,parseInt(rowcount),abstraction[idx],host);
          }
        },
        _fillHeaderRow:function(row,rowCount,data,host){
          for(var cellIdx in data){
            var trueCellIdx = !this.indexed?parseInt(cellIdx):parseInt(cellIdx)+1;
            var cell = host.header.getCell(row,trueCellIdx);
            var props = data[cellIdx];
            if(props.colspan){cell.colspan = props.colspan}
            if(row==(rowCount-1)){
              if(this.indexed){ // apply index text content to header cell
                host.header.getCell(row,0).content = host.columns[0].headerContent;
              }
              if(host.columns[trueCellIdx].headerContent && host.columns[trueCellIdx].headerContent.length>0 && this.columnHeaderOverride){ //if we need to override and we have text to override with
                cell.content = host.columns[trueCellIdx].headerContent;
                if(!host.columns[trueCellIdx].hidingToggleText){host.columns[trueCellIdx].hidingToggleText = host.columns[trueCellIdx].headerContent;}
              } else {
                cell.content = props.label;
                if(!host.columns[trueCellIdx].hidingToggleText){host.columns[trueCellIdx].hidingToggleText = props.label;}
              }
            } else {
              cell.content=props.label;
            }
          }
        },
        _sortChange:function(e){
            var idx = this.grid.sortOrder[0].column;
            /*if this column was sorted before just flip it*/
            if(this._sortedColumn === idx){
              this.data.reverse();
            } else { //not sorted
              this.sorter();
            }
            this._sortedColumn = this.grid.sortOrder[0].column;
        },
        sorter:function(){
          var grid = this.grid;
          var idx = grid.sortOrder[0].column;
          var lesser = grid.sortOrder[0].direction === 'asc' ? -1 : 1;
          this.data.sort(function(a,b){
            var x,y;
            x = a[idx]; y = b[idx];
            var regex = /[<>]/g;
            if(regex.test(x) || regex.test(y)){ // if we need to sort elements that have HTML like links
              var tempEl1 = document.createElement('span'); tempEl1.innerHTML = x;
              x=tempEl1.textContent.trim();
              var tempEl2 = document.createElement('span'); tempEl2.innerHTML = y;
              y=tempEl2.textContent.trim();
            }
            //console.log( document.createElement('span').innerHTML=)
            if(!isNaN(parseFloat(x)) && !isNaN(parseFloat(y))){
              return parseFloat(x) <  parseFloat(y) ? lesser :  parseFloat(x) >  parseFloat(y) ? -lesser : 0;
            } else {
              return x.toLowerCase() < y.toLowerCase() ? lesser : x.toLowerCase() > y.toLowerCase() ? -lesser : 0;
            }
          });
        },
      });
    })();
  </script>
</dom-module>
