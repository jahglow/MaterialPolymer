<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="..\..\bower_components/polymer/polymer.html">
<link rel="import" href="..\..\bower_components/vaadin-grid/vaadin-grid.html">

<dom-module id="reportal-aggregated-table">
  <template>
    <style>
      :host {
        display: block;
      }
      #source{display:none}
    </style>
    <div id="source"><content></content></div>
    <div id="grid"></div>
  </template>


  <script>



    (function(){
      'use strict';

      Polymer({
        is: 'reportal-aggregated-table',
        listeners:{
          'tap':'_sortChange'
        },

        properties: {
          selectionMode:{
            type:String,
            value: 'single'
          },
          frozenColumns:String,
          colattrLegacy:{
            type:String,
            value:''
          },
          colattr:{
            type:Array,
            value:[]
          },
          columnHeaderOverride:{
            type:Boolean,
            value:false
          },
          data:{
            type:Array,
            value:[]
          },
          sortedColumn:{
            type:Number,
            value:null
          },
          /* firstColumnHeadr allows to set the header of the first column (unsupported by Reportal natively)*/
          firstColumnHeader:String,
          visibleRows:String
        },
        ready:function(){
            if(this.colattrLegacy && this.colattrLegacy.length>0){
              this._processLegacyAttributes(this.colattrLegacy);
            }

            var gridAttributes=[];
            gridAttributes.push(this._defineAttr('selection-mode',this.selectionMode));
            gridAttributes.push(this._defineAttr('frozen-columns',this.frozenColumns));
            gridAttributes.push(this._defineAttr('visible-rows',this.visibleRows));
            this._defineColumns();
            this._defineData(this.$.source.querySelector('table'));
            Polymer.dom(this.$.grid).innerHTML = '<vaadin-grid'+gridAttributes.join(' ')+'>' + this.$.source.innerHTML + '</vaadin-grid>';
            this.grid = this.$.grid.querySelector('vaadin-grid');
            this.grid.items = this.data;
        },
        attached:function(){

        },
        _defineData:function(table){
          var rows = table.querySelectorAll('tbody tr');
          for(var i=0;i<rows.length;i++){
            var curRow=[];
            for(var ri=0;ri<rows[i].children.length;ri++){
              curRow.push(rows[i].children[ri].textContent);
            }
            this.data.push(curRow);
          }
        },
        _defineAttr:function(propN,propV){
          if(propV){
            if(typeof propV === 'string'){
              return ' '+propN+'="'+propV+'"';
            } else if (typeof propV === 'boolean') {
              return ' '+propN;
            }
          }
        },
        _processLegacyAttributes:function(data){
          var aColAttrs=data.split(';'),attrPairs,attrPair,tempA=[];
          for(var i=0;i<aColAttrs.length;i++){
            var tempColAttr=[];
            if(aColAttrs[i].length>0){
              attrPairs=aColAttrs[i].split('|');
              for(var ap=0;ap<attrPairs.length;ap++){
                if(attrPairs[ap].length>0){
                  attrPair=attrPairs[ap].split(':');
                  tempColAttr.push(attrPair);
                }
              }
            }
            this.colattr.push(tempColAttr);
          }
          console.log(this.colattr);
        },
        _defineColumns:function(){
          if(this.$.source.querySelectorAll('thead tr').length>1){ //double header row
            var topRowTH = this.$.source.querySelector('thead tr:first-child th');
            var rowspan = topRowTH.getAttribute('rowspan');
            for(var ri=1;ri<rowspan;ri++){
              var curRow=this.$.source.querySelectorAll('thead tr')[ri];
              curRow.insertBefore(document.createElement('th'),curRow.firstChild);
            }
            topRowTH.removeAttribute('rowspan');
          } else if(this.$.source.querySelectorAll('thead tr:last-child th').length < this.$.source.querySelectorAll('tbody tr:last-child td')) {
            Polymer.dom(this.$.source.querySelector('thead tr:last-child')).insertBefore(document.createElement('th'),this.$.source.querySelector('thead tr:last-child th:first-child'));
          }
          var num=this.$.source.querySelector('thead').lastElementChild.children.length;
          var table = this.$.source.querySelector('table');
          var colgroup = document.createElement('colgroup');
          /* set the header for the first table column if it's not specified via header-text on parameters */
          if(this.firstColumnHeader && !this.columnHeaderOverride){
            this.$.source.querySelector('thead tr:last-child th:first-child').textContent = this.firstColumnHeader;
          }
          var colheader = this.$.source.querySelectorAll('thead tr:last-child th');
          for(var i=0;i<num;i++){
            var col = document.createElement('col');
            if(this.colattr && this.colattr[i]) {
              var hasHeader = false;
              for (var ai = 0; ai < this.colattr[i].length; ai++) {
                if(this.colattr[i][ai].length>1){
                  Polymer.dom(col).setAttribute(this.colattr[i][ai][0], this.colattr[i][ai][1]);
                  if(this.colattr[i][ai][0]==='header-text'){
                    hasHeader = true;
                    /*if there is override or this is the first column and title was passed as parameter and not as firstColumnHeader */
                    if(this.columnHeaderOverride || (i===0 && !this.columnHeaderOverride && !this.firstColumnHeader)){
                      Polymer.dom(colheader[i]).textContent=this.colattr[i][ai][1];
                    }
                  }
                } else {
                  Polymer.dom(col).setAttribute(this.colattr[i][ai][0], '');
                }
                if(ai === this.colattr[i].length-1 && hasHeader === false ){
                  Polymer.dom(col).setAttribute('header-text', Polymer.dom(colheader[i]).textContent);
                }
              }
            }
            Polymer.dom(colgroup).appendChild(col);
          }
          Polymer.dom(table).insertBefore(colgroup, table.firstChild);
        },
        _sortChange:function(e){
          if(e.target.classList.contains('sort-desc') || e.target.classList.contains('sort-asc') ){
            var idx = this.grid.data.sortOrder[0].column;
            /*if this column was sorted before just flip it*/
            if(this.sortedColumn === idx){
              this.data.reverse();
              this.grid.data.clearCache();
            } else { //not sorted
              this.sorter();
              this.grid.data.clearCache();
            }
            this.sortedColumn = this.grid.data.sortOrder[0].column;
          }
        },
        sorter:function(){
          var grid = this.grid || this.$.grid.querySelector('vaadin-grid');
          var idx = grid.data.sortOrder[0].column;
          var lesser = grid.data.sortOrder[0].direction == 'asc' ? -1 : 1;
          this.data.sort(function(a,b){
            var x,y;
            x = a[idx]; y = b[idx];
            if(!isNaN(parseFloat(x)) && !isNaN(parseFloat(y))){
              return parseFloat(x) <  parseFloat(y) ? lesser :  parseFloat(x) >  parseFloat(y) ? -lesser : 0;
            } else {
              return x.toLowerCase() < y.toLowerCase() ? lesser : x.toLowerCase() > y.toLowerCase() ? -lesser : 0;
            }
          });
        }
      });
    })();
  </script>
</dom-module>
