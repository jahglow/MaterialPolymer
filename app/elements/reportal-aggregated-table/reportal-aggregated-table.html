<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="..\..\bower_components/polymer/polymer.html">
<link rel="import" href="..\..\bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="..\..\bower_components/iron-resizable-behavior/iron-resizable-behavior.html">


<dom-module id="reportal-aggregated-table">
  <template>
    <style>
      :host {
        display: block;
        width:100%;
        height:auto
      }
      #source{display:none}
      #grid>vaadin-grid .numeric{text-align: right}
    </style>
    <div id="source"><content></content></div>
    <div id="grid"></div>
  </template>
  <script>
    (function(){
      'use strict';

      Polymer({
        is: 'reportal-aggregated-table',
        hostAttributes: {
          'column-header-override': true
        },
        listeners:{
          'tap':'_sortChange'
        },
        behaviors: [
          Polymer.IronResizableBehavior
        ],

        properties: {
          selectionMode:{
            type:String,
            value: 'disabled'
          },
          frozenColumns:{
            type:Number,
            value:0
          },
          colattrLegacy:{
            type:String,
            value:''
          },
          colattr:{
            type:Array,
            value:[]
          },
          columnHeaderOverride:{
            type:Boolean,
            value:false
          },
          data:{
            type:Array,
            value:[],
            notify:true
          },
          _sortedColumn:{
            type:Number,
            value:null
          },
          indexed:{
            type:Boolean,
            value:false
          },
          indexedHeader:{
            type:String,
            value:'#'
          },
          /* firstColumnHeadr allows to set the header of the first column (unsupported by Reportal natively)*/
          firstColumnHeader:String,
          visibleRows:Number,
          vaadinID:String,
          renderer:{
            type: Object,
            value: function(){
              return {
                html:function(cell){
                  cell.element.innerHTML = cell.data;
                }
              }
            }
          },

        },
        ready:function(){
          if(this.colattrLegacy && this.colattrLegacy.length>0){
            this._processLegacyAttributes(this.colattrLegacy);
          }
          var grid = document.createElement('vaadin-grid');
          var table = this.$.source.querySelector('table');
          if(table){
            this.grid = grid;
            this._defineData(this.$.source.querySelector('table'));
            this._defineHeader(grid);
            console.log(Polymer.dom(grid));
            if(this.visibleRows){grid.rows=this.visibleRows;}
            if(this.selectionMode){grid.selection.mode=this.selectionMode;}
            if(this.frozenColumns){
              if(this.indexed){this.frozenColumns+=1;}
              grid.frozenColumns=this.frozenColumns;
            }
            this.vaadinID = this._guid();
            Polymer.dom(grid).setAttribute('id',this.vaadinID);
            Polymer.dom(this.$.grid).appendChild(grid);
          }
        },
        attached:function(){
            this.async(this.notifyResize,100);
        },
        _defineData:function(table){
          this.data=[];var rows;
          for(var ch=0;ch<table.children.length;ch++){
            // we want to get the topmost table and not its cells content tables if any
            if(table.children[ch].localName==='tbody'){rows=table.children[ch].children; break;}
          }
          if(rows){
            for(var i=0;i<rows.length;i++){
              var curRow=[];
              if(this.indexed){curRow.push(i+1);}//append index
              for(var ri=0;ri<rows[i].children.length;ri++){
                curRow.push(rows[i].children[ri].children.length>0?rows[i].children[ri].innerHTML:rows[i].children[ri].textContent.trim());
                var csp=rows[i].children[ri].getAttribute('colspan');
                if(csp){
                  for(var ci=1;ci<csp;ci++){
                    curRow.push('');
                  }
                }
              }
              this.data.push(curRow);
            }
          }
          this.grid.items = this.data;
          this.grid.cellClassGenerator = function(cell){
            console.log(rows[cell.row.index].children[cell.index].className);
            return rows[cell.row.index].children[cell.index].className;
          };
        },
        /*_defineAttr:function(propN,propV){
          if(propV){
            if(typeof propV === 'string'){
              return ' '+propN+'="'+propV+'"';
            } else if (typeof propV === 'boolean') {
              return ' '+propN;
            }
          }
        },*/
        /**
         * Converts array["key","value"] to object {key:"value"} respecting int,string,bool
         */
        _a2o:function(obj,key,val){
          if(obj && key){
            if(val && val.length>0){
              if(key!=='renderer'){
                obj[key]=this._isInt(val)?parseInt(val):val;
              } else { // process renderers via this.renderer.Renderer_name property
                obj[key]=this.renderer[val];
              }
            } else {obj[key]=true;} //it's a boolean
          }
        },
        /**
         * Checks if value is a number
         */
        _isInt:function(val){
          return (!isNaN(parseInt(val)) && parseInt(val).toString().length===val.length);
        },
        _processLegacyAttributes:function(data){
          var aColAttrs=data.split(';'),attrPairs,attrPair;
          for(var i=0;i<aColAttrs.length;i++){
            var tempColAttr=[];
            if(aColAttrs[i].length>0){
              attrPairs=aColAttrs[i].split('|');
              for(var ap=0;ap<attrPairs.length;ap++){
                if(attrPairs[ap].length>0){
                  attrPair=attrPairs[ap].split(':');
                  tempColAttr.push(attrPair);
                }
              }
            }
            this.colattr.push(tempColAttr);
          }
        },
        _defineHeader:function(host){
          //first define column quantity of the table
          var columns = this.data[0]|| this.$.source.querySelectorAll('tbody tr:last-child td');
          if(this.indexed){
            host.addColumn({headerContent:this.indexedHeader, maxWidth:'100px', sortable:true}); //append index
          }
          if(columns && columns.length>0){
            var colattr = this.colattr;
            for(var i=0;i<columns.length;i++){
              var colProp = {};
              if(colattr[i]){
                for(var ci=0;ci<colattr[i].length;ci++){ // populate column properties
                  if(colattr[i][ci].length>0){
                    this._a2o(colProp,colattr[i][ci][0],colattr[i][ci][1]);
                  }
                }
              }
              host.addColumn(colProp);
            }
          }
          console.log(host.columns);
          // then define number of rows in the header
          var headerRows =  this.$.source.querySelectorAll('table:first-child>thead>tr');
            for(var hr=0;hr<headerRows.length;hr++){
              if(hr>0){host.header.addRow();} // add next row else fill first row
              if(hr===headerRows.length-1){host.header.defaultRow = headerRows.length-1;} //set default(bottom) row of header for sorting and such
              var ths = headerRows[hr].children;
              var columnIncr=0;
              if(hr>0){
                columnIncr++;
              }
              if(this.indexed){
                columnIncr++;
              }
              for(var thsi = 0;thsi<ths.length;thsi++){
                //detect if there's a colspan on the column and
                var THcolspan = ths[thsi].getAttribute('colspan');
                var tmpCell=host.header.getCell(hr,columnIncr);
                // if it's last header row && this cell has contents && col doesn't have headerText or it does, but there isn't header override, pass this value to col
                if(hr===headerRows.length-1 ){ // if it's the main row
                  if(THcolspan){host.header.getCell(hr, !this.indexed?thsi:thsi+1).colspan = THcolspan;}
                  console.log(tmpCell);
                  if(host.columns[columnIncr].headerContent.length>0 && this.columnHeaderOverride){
                    tmpCell.content = host.columns[columnIncr].headerContent;
                    if(!host.columns[columnIncr].hidingToggleText){host.columns[columnIncr].hidingToggleText = host.columns[columnIncr].headerContent;}
                  } else {
                    tmpCell.content = ths[thsi].textContent;
                    if(!host.columns[columnIncr].hidingToggleText){host.columns[columnIncr].hidingToggleText = ths[thsi].textContent;}
                  }
                } else {
                  tmpCell.content = ths[thsi].textContent;
                }
                if(THcolspan){
                  //tmpCell.colspan = THcolspan;
                  columnIncr += THcolspan-1;
                }
                columnIncr++;
              }
            }
        },
        _sortChange:function(e){
          if(e.target.classList.contains('sort-desc') || e.target.classList.contains('sort-asc') ){
            var idx = this.grid.data.sortOrder[0].column;
            /*if this column was sorted before just flip it*/
            if(this._sortedColumn === idx){
              this.data.reverse();
              this.grid.data.clearCache();
            } else { //not sorted
              this.sorter();
              this.grid.data.clearCache();
            }
            this._sortedColumn = this.grid.data.sortOrder[0].column;
          } else if(e.target.parentElement.localName === 'th' && e.target.parentElement.classList.contains('vaadin-grid-cell')){e.target.parentElement.click();}
        },
        sorter:function(){
          var grid = this.grid;
          var idx = grid.data.sortOrder[0].column;
          var lesser = grid.data.sortOrder[0].direction === 'asc' ? -1 : 1;
          this.data.sort(function(a,b){
            var x,y;
            x = a[idx]; y = b[idx];
            if(!isNaN(parseFloat(x)) && !isNaN(parseFloat(y))){
              return parseFloat(x) <  parseFloat(y) ? lesser :  parseFloat(x) >  parseFloat(y) ? -lesser : 0;
            } else {
              return x.toLowerCase() < y.toLowerCase() ? lesser : x.toLowerCase() > y.toLowerCase() ? -lesser : 0;
            }
          });
        },
        _guid:function(){
          var S4 = function(){
            return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
          };
          // then to call it, plus stitch in '4' in the third group
          var guid = (S4() + S4() + '_' + S4() ).toLowerCase();
          return(guid);
        }
      });
    })();
  </script>
</dom-module>
