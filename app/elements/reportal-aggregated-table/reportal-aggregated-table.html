<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="..\..\bower_components/polymer/polymer.html">
<link rel="import" href="..\..\bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="..\..\bower_components/iron-resizable-behavior/iron-resizable-behavior.html">


<dom-module id="reportal-aggregated-table">
  <template>
    <style>
      :host {
        display: block;
        width:100%;
        height:auto
      }
      #source{display:none}
      #grid>vaadin-grid .numeric{text-align: right}
    </style>
    <div id="source"><content></content></div>
    <div id="grid"></div>
  </template>
  <script>
    (function(){
      'use strict';

      Polymer({
        is: 'reportal-aggregated-table',
        hostAttributes: {
          'column-header-override': true
        },
        listeners:{
          'tap':'_sortChange'
        },
        behaviors: [
          Polymer.IronResizableBehavior
        ],

        properties: {
          selectionMode:{
            type:String,
            value: 'disabled'
          },
          frozenColumns:{
            type:Number,
            value:0
          },
          colattrLegacy:{
            type:String,
            value:''
          },
          colattr:{
            type:Array,
            value:[]
          },
          columnHeaderOverride:{
            type:Boolean,
            value:false
          },
          data:{
            type:Array,
            value:[],
            notify:true
          },
          _sortedColumn:{
            type:Number,
            value:null
          },
          indexed:{
            type:Boolean,
            value:false
          },
          indexedHeader:{
            type:String,
            value:'#'
          },
          /* firstColumnHeadr allows to set the header of the first column (unsupported by Reportal natively)*/
          firstColumnHeader:String,
          visibleRows:Number,
          vaadinID:String,
          renderer:{
            type: Object,
            value: function(){
              return {
                html:function(cell){
                  cell.element.innerHTML = cell.data;
                }
              }
            }
          },

        },
        ready:function(){
          if(this.colattrLegacy && this.colattrLegacy.length>0){
            this._processLegacyAttributes(this.colattrLegacy);
          }
          var grid = document.createElement('vaadin-grid');
          var table = this.$.source.querySelector('table');
          if(table){
            this.grid = grid;
            this._defineData(table);
            this._defineHeader(grid,table);
            if(this.visibleRows){grid.rows=this.visibleRows;}
            if(this.selectionMode){grid.selection.mode=this.selectionMode;}
            if(this.frozenColumns){
              if(this.indexed){this.frozenColumns+=1;}
              grid.frozenColumns=this.frozenColumns;
            }
            this.vaadinID = this._guid();
            Polymer.dom(grid).setAttribute('id',this.vaadinID);
            Polymer.dom(this.$.grid).appendChild(grid);
          }
        },
        attached:function(){
          this.async(this.notifyResize,100);
        },
        _defineData:function(table){
          this.data=[];
          var rows;
          for(var ch=0;ch<table.children.length;ch++){
            // we want to get the topmost table and not its cells content tables if any
            if(table.children[ch].localName==='tbody'){rows=table.children[ch].children; break;}
          }
          if(rows){
            for(var i=0;i<rows.length;i++){
              var curRow=[];
              if(this.indexed){curRow.push(i+1);}//append index
              for(var ri=0;ri<rows[i].children.length;ri++){
                curRow.push(rows[i].children[ri].children.length>0?rows[i].children[ri].innerHTML:rows[i].children[ri].textContent.trim());
                var csp=rows[i].children[ri].getAttribute('colspan');
                if(csp){
                  for(var ci=1;ci<csp;ci++){
                    curRow.push('');
                  }
                }
              }
              this.data.push(curRow);
            }
          }
          this.grid.items = this.data;
          console.log(this.grid.items)
          // append conditional formatting from corresponding table cells
          this.grid.cellClassGenerator = function(cell){
            return rows[cell.row.index].children[cell.index].className;
          };
        },
        /*_defineAttr:function(propN,propV){
         if(propV){
         if(typeof propV === 'string'){
         return ' '+propN+'="'+propV+'"';
         } else if (typeof propV === 'boolean') {
         return ' '+propN;
         }
         }
         },*/
        /**
         * Converts array["key","value"] to object {key:"value"} respecting int,string,bool
         */
        _a2o:function(obj,key,val){
          if(obj && key){
            if(val && val.length>0){
              if(key!=='renderer'){
                obj[key]=this._isInt(val)?parseInt(val):val;
              } else { // process renderers via this.renderer.Renderer_name property
                obj[key]=this.renderer[val];
              }
            } else {obj[key]=true;} //it's a boolean
          }
        },
        /**
         * Checks if value is a number
         */
        _isInt:function(val){
          return (!isNaN(parseInt(val)) && parseInt(val).toString().length===val.length);
        },
        _processLegacyAttributes:function(data){
          var aColAttrs=data.split(';'),attrPairs,attrPair;
          for(var i=0;i<aColAttrs.length;i++){
            var tempColAttr=[];
            if(aColAttrs[i].length>0){
              attrPairs=aColAttrs[i].split('|');
              for(var ap=0;ap<attrPairs.length;ap++){
                if(attrPairs[ap].length>0){
                  attrPair=attrPairs[ap].split(':');
                  tempColAttr.push(attrPair);
                }
              }
            }
            this.colattr.push(tempColAttr);
          }
        },
        _defineHeader:function(host,source){
          Object.size = function(obj) {
            var size = 0, key;
            for (key in obj) {
              if (obj.hasOwnProperty(key)) size++;
            }
            return size;
          };

          //first define column quantity of the table
          var columns = this._getImmediateChildrenByName(source,'tbody')[0].lastElementChild.children;
          var columnsCount = columns.length;

          if(this.indexed){
            host.addColumn({headerContent:this.indexedHeader, maxWidth:'100px', sortable:true}); //append index
            columnsCount++;
          }
          //console.log('total columns: '+columnsCount);
          var thead = this._getImmediateChildrenByName(source,'thead')[0];
          var rowcount = thead.children.length;
          //console.log('rowcount '+rowcount);
          var abstraction = {};
          for(var a=0;a<rowcount;a++){
            var realRow = thead.children[a]; //real row
            //console.log(realRow);
            //console.log('row '+a +'exists? '+abstraction.hasOwnProperty(a.toString()));
            var aRow = abstraction[a] = abstraction[a] || {}; //abstraction row (might exist)
            //console.log('row '+a +'exists? '+abstraction.hasOwnProperty(a.toString()));

            var aRowLength = 0;
            for(var rowTD = 0; rowTD<realRow.children.length;rowTD++){
              var curTD = realRow.children[rowTD]; //current cell
              var realIndex;
              //console.log(curTD);
              var colspan = curTD.colSpan;
              var rowspan = curTD.rowSpan;
              var label = curTD.textContent;
              //console.log('colSpan '+ colspan)
              //console.log('rowspan '+rowspan)
              //console.log('label '+label)

              if(colspan||rowspan||label){
                var finalTDcellIndex=rowTD;
                /* if entry exists (there was a rowspan in previous row and it transferred label to next possible row), we need to find a new home for curTD
                 * all cells are filled sequentially, so we need to find a break in indexing sequence*/
                //console.log(aRow.hasOwnProperty(rowTD))// create cell for this abstract row
                if(aRow.hasOwnProperty(rowTD)) { //this entry exists (it can exist if was filled by previous row where a cell had a rowspan)
                  //console.log(rowTD+' cell exists, will search for new place');
                  var realTDindex = 0;
                  var cellIsFound = false;
                  for (key in aRow) {
                    if (parseInt(key) === realTDindex) {
                      //console.log(key+' cell is also used');
                      realTDindex++
                    } else {
                      cellIsFound = true;
                      //console.log(realTDindex+' cell is just perfect');
                      finalTDcellIndex = realTDindex;
                      break;
                    }
                  }
                  if(!cellIsFound){
                    //console.log('we\'ve ran out of options with'+ realTDindex+' cell, let\'s make it a '+ realTDindex+1 +' ?');
                    finalTDcellIndex = realTDindex++;
                  }
                }
                var key = a; //is this current row or it has rowspan and we append label to the bottommost row?
                //console.log('has rowspan, current row is' + a+' cell is '+finalTDcellIndex);
                if(!rowspan){rowspan=1}
                for(var ri=0;ri<rowspan;ri++){
                  if(rowspan){key=a+ri;}
                  //console.log('row is '+key);
                  //console.log('from rowspan row '+key+' exists? '+abstraction.hasOwnProperty(key))
                  if(!abstraction.hasOwnProperty(key)){abstraction[key]={}}// is there such a row in abstraction?
                  //console.log('from rowspan cell '+finalTDcellIndex+' exists? '+abstraction[key].hasOwnProperty(finalTDcellIndex))
                  if(!abstraction[key].hasOwnProperty(finalTDcellIndex)){
                    abstraction[key][finalTDcellIndex]={};
                    if(ri===rowspan-1){ // if it's the last row
                      abstraction[key][finalTDcellIndex].label = label.trim().length>0?label.trim():''; // use label if more than empty else empty string
                    } else {abstraction[key][finalTDcellIndex].label = ''}
                  } else {

                  }
                  if(colspan>1){abstraction[key][finalTDcellIndex].colspan = colspan;}
                }
                if(abstraction[key]!==abstraction[a]){aRow[finalTDcellIndex].label = ''} // if there was rowspan, this cell is empty and needs empty label
              } else {aRow[rowTD].label=''}
              //console.log(JSON.stringify(abstraction));
              aRowLength++;
            }
          }

          if(columns && columns.length>0){
            var colattr = this.colattr;
            for(var i=0;i<columns.length;i++){
              var colProp = {};
              if(colattr[i]){
                for(var ci=0;ci<colattr[i].length;ci++){ // populate column properties
                  if(colattr[i][ci].length>0){
                    this._a2o(colProp,colattr[i][ci][0],colattr[i][ci][1]);
                  }
                }
              }
              host.addColumn(colProp);
            }
          }

          for(var idx in abstraction){
            if(idx>0){
              console.log('will add a row');
              host.header.addRow();
            }
            console.log(typeof parseInt(idx));
            if(parseInt(idx)===(parseInt(rowcount)-1)){
              host.header.defaultRow = parseInt(rowcount)-1;
              console.log('defaultRow '+host.header.defaultRow);
            }
            this._fillHeaderRow(idx,parseInt(rowcount),abstraction[idx],host);
          }
        },
        _fillHeaderRow:function(row,rowCount,data,host){
          for(var cellIdx in data){
            var trueCellIdx = !this.indexed?parseInt(cellIdx):parseInt(cellIdx)+1;
            var cell = host.header.getCell(row,trueCellIdx);
            var props = data[cellIdx];
            if(props.colspan){cell.colspan = props.colspan}
            if(row==(rowCount-1)){
              if(this.indexed){ // apply index text content to header cell
                host.header.getCell(row,0).content = host.columns[0].headerContent;
              }
              if(host.columns[trueCellIdx].headerContent && host.columns[trueCellIdx].headerContent.length>0 && this.columnHeaderOverride){ //if we need to override and we have text to override with
                cell.content = host.columns[trueCellIdx].headerContent;
                if(!host.columns[trueCellIdx].hidingToggleText){host.columns[trueCellIdx].hidingToggleText = host.columns[trueCellIdx].headerContent;}
              } else {
                cell.content = props.label;
                if(!host.columns[trueCellIdx].hidingToggleText){host.columns[trueCellIdx].hidingToggleText = props.label;}
              }
            } else {
              cell.content=props.label;
            }
          }
        },
        _sortChange:function(e){
          console.log(e);
          if(e.target.classList.contains('sort-desc') || e.target.classList.contains('sort-asc') ){
            console.log(Polymer.dom(this.grid));
            var idx = this.grid.sortOrder[0].column;
            console.log(idx);
            /*if this column was sorted before just flip it*/
            if(this._sortedColumn === idx){
              this.data.reverse();
              this.grid.refreshItems();
            } else { //not sorted
              this.sorter();
              this.grid.refreshItems();
            }
            this._sortedColumn = this.grid.sortOrder[0].column;
          } else if(e.target.parentElement.localName === 'th' && e.target.parentElement.classList.contains('vaadin-grid-cell')){e.target.parentElement.click();}
        },
        sorter:function(){
          var grid = this.grid;
          var idx = grid.sortOrder[0].column;
          var lesser = grid.sortOrder[0].direction === 'asc' ? -1 : 1;
          this.data.sort(function(a,b){
            var x,y;
            x = a[idx]; y = b[idx];
            if(!isNaN(parseFloat(x)) && !isNaN(parseFloat(y))){
              return parseFloat(x) <  parseFloat(y) ? lesser :  parseFloat(x) >  parseFloat(y) ? -lesser : 0;
            } else {
              return x.toLowerCase() < y.toLowerCase() ? lesser : x.toLowerCase() > y.toLowerCase() ? -lesser : 0;
            }
          });
        },
        _getImmediateChildrenByName:function(source, tagname){
          return Polymer.dom(source).children.filter(function(item){return item.localName===tagname});
        },
        _guid:function(){
          var S4 = function(){
            return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
          };
          // then to call it, plus stitch in '4' in the third group
          var guid = (S4() + S4() + '_' + S4() ).toLowerCase();
          return(guid);
        }
      });
    })();
  </script>
</dom-module>
